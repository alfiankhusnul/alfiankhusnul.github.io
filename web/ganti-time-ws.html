<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Batch Update Timestamp project.csv di ZIP</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body class="min-h-screen bg-slate-50 text-slate-800">
  <div class="max-w-4xl mx-auto p-6">
    <header class="mb-6">
      <h1 class="text-2xl font-bold">Batch Update <code>created_at</code> di <code>project.csv</code> dalam ZIP</h1>
      <p class="text-sm text-slate-600 mt-2">Mengganti tanggal pada kolom <code>created_at</code> (epoch ms) menjadi tanggal input, sambil mempertahankan jam:menit:detik dari nilai lama. File lain di dalam ZIP tetap utuh dengan metadata terjaga.</p>
    </header>

    <section class="grid gap-4 sm:grid-cols-2 bg-white rounded-2xl shadow p-4">
      <div>
        <label class="block text-sm font-medium mb-1">Tanggal baru (YYYY-MM-DD)</label>
        <input id="dateInput" type="date" class="w-full rounded-xl border border-slate-300 p-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" required />
      </div>
      <div>
        <label class="block text-sm font-medium mb-1">Zona waktu untuk mempertahankan jam-menit-detik</label>
        <select id="tzSelect" class="w-full rounded-xl border border-slate-300 p-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
          <option value="420">UTC+07:00 (WIB)</option>
          <option value="480" selected>UTC+08:00 (WITA)</option>
          <option value="540">UTC+09:00 (WIT)</option>
          <option value="0">UTC±00:00</option>
        </select>
        <p class="text-xs text-slate-500 mt-1">Contoh: jika timestamp lama menunjukkan 15:03:23 di WITA, maka hasil akan menjadi <em>tanggal input</em> + <code>15:03:23</code> (WITA) lalu dikonversi kembali ke epoch (ms).</p>
      </div>
      <div class="sm:col-span-2">
        <label class="block text-sm font-medium mb-1">Pilih file ZIP (bisa banyak)</label>
        <input id="zipInput" type="file" accept=".zip" multiple class="w-full rounded-xl border border-slate-300 p-2" />
      </div>
      <div class="sm:col-span-2">
        <div class="flex items-center gap-3 p-3 bg-blue-50 rounded-xl border border-blue-200">
          <label class="relative inline-flex items-center cursor-pointer">
            <input id="forceNewProject" type="checkbox" class="sr-only peer">
            <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
          </label>
          <div>
            <label for="forceNewProject" class="text-sm font-medium text-blue-900 cursor-pointer">Paksa Project Baru</label>
            <p class="text-xs text-blue-600">Reset server_id dan is_sent pada project.csv & landmark.csv untuk membuat project baru</p>
          </div>
        </div>
      </div>
      <div class="sm:col-span-2 flex gap-3">
        <button id="btnProcess" class="px-4 py-2 rounded-2xl bg-indigo-600 text-white font-medium shadow hover:bg-indigo-700 disabled:opacity-50">Proses & Unduh Hasil</button>
        <button id="btnClear" class="px-4 py-2 rounded-2xl bg-slate-200 text-slate-800 font-medium shadow hover:bg-slate-300">Bersihkan</button>
      </div>
    </section>

    <section class="mt-6">
      <h2 class="font-semibold mb-2">Progress</h2>
      <div id="log" class="text-sm bg-white rounded-2xl shadow p-3 h-56 overflow-auto whitespace-pre-wrap"></div>
    </section>

    <section class="mt-6">
      <h2 class="font-semibold mb-2">Unduhan</h2>
      <div id="downloads" class="grid gap-2"></div>
    </section>
  </div>

<script>
  const logEl = document.getElementById('log');
  const downloadsEl = document.getElementById('downloads');
  const btnProcess = document.getElementById('btnProcess');
  const btnClear = document.getElementById('btnClear');

  function log(msg) {
    const time = new Date().toLocaleTimeString();
    logEl.textContent += `[${time}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }

  function pad(n){ return String(n).padStart(2,'0'); }

  // Ambil komponen jam-menit-detik lama pada zona waktu offset tertentu (dalam menit, contoh 480 untuk UTC+8)
  function extractHMSFromEpochMs(epochMs, tzOffsetMinutes) {
    const shifted = new Date(epochMs + tzOffsetMinutes * 60000); // geser ke "waktu lokal" yg diinginkan
    return {
      h: shifted.getUTCHours(),
      m: shifted.getUTCMinutes(),
      s: shifted.getUTCSeconds(),
      ms: shifted.getUTCMilliseconds(),
    };
  }

  // Bangun epoch ms dari (tanggal Y-M-D) + (h:m:s.ms) pada zona waktu offset tertentu
  function buildEpochMsFromLocalYMDHMS(year, month, day, h, m, s, ms, tzOffsetMinutes) {
    const utcMs = Date.UTC(year, month - 1, day, h, m, s, ms);
    // Kurangi offset untuk kembali ke UTC epoch
    return utcMs - tzOffsetMinutes * 60000;
  }

  // Process CSV dengan opsi reset untuk project baru
  async function processCsv(csvText, csvType, dateStr, tzOffsetMinutes, forceNewProject) {
    // Parse CSV dengan settings yang lebih ketat
    const parsed = Papa.parse(csvText, { 
      header: true, 
      skipEmptyLines: true,
      dynamicTyping: false, // jangan auto-convert tipe data
      trimHeaders: true, // bersihkan whitespace di header
      delimiter: ";" // gunakan semicolon sebagai separator
    });

    if (parsed.errors && parsed.errors.length) {
      log(`  ⚠️ Peringatan parse ${csvType}: ${parsed.errors[0].message}`);
    }

    const rows = parsed.data;
    const fields = (parsed.meta && parsed.meta.fields && parsed.meta.fields.length)
      ? parsed.meta.fields
      : (rows.length ? Object.keys(rows[0]) : []);

    let changed = 0;

    if (csvType === 'project.csv') {
      // Process project.csv
      if (!fields.includes('created_at')) {
        log(`  ➜ Kolom created_at tidak ditemukan di ${csvType} (dilewati).`);
        return null;
      }

      const [Y, M, D] = dateStr.split('-').map(n => parseInt(n, 10));
      
      rows.forEach((row, idx) => {
        // Update created_at timestamp
        const raw = row['created_at'];
        if (raw != null && raw !== '') {
          let oldMs = Number(raw);
          if (Number.isFinite(oldMs)) {
            const { h, m, s, ms } = extractHMSFromEpochMs(oldMs, tzOffsetMinutes);
            const newMs = buildEpochMsFromLocalYMDHMS(Y, M, D, h, m, s, ms, tzOffsetMinutes);
            row['created_at'] = String(newMs);
            changed++;
          }
        }

        // Reset untuk project baru jika diminta
        if (forceNewProject) {
          if (fields.includes('server_id_project')) {
            row['server_id_project'] = '0';
          }
          if (fields.includes('is_sent')) {
            row['is_sent'] = 'false';
          }
        }
      });

    } else if (csvType === 'landmark.csv' && forceNewProject) {
      // Process landmark.csv hanya jika forceNewProject aktif
      rows.forEach((row, idx) => {
        if (fields.includes('server_id_landmark')) {
          row['server_id_landmark'] = '0';
          changed++;
        }
        if (fields.includes('server_id_project')) {
          row['server_id_project'] = '0';
          changed++;
        }
        if (fields.includes('is_sent')) {
          row['is_sent'] = 'false';
          changed++;
        }
      });
    }

    if (changed === 0 && csvType === 'landmark.csv' && !forceNewProject) {
      return null; // Tidak ada perubahan pada landmark.csv jika tidak force new project
    }

    // Serialize kembali ke CSV
    const dataMatrix = rows.map(r => fields.map(f => r[f] ?? ''));
    const newCsv = Papa.unparse({ 
      fields, 
      data: dataMatrix 
    }, {
      quotes: false, // hindari quote berlebihan
      delimiter: ";", // gunakan semicolon sebagai separator
      header: true,
      newline: "\r\n" // gunakan CRLF untuk kompatibilitas Windows
    });

    return { csvContent: newCsv, changed };
  }
  // Preserve metadata dengan minimal ZIP recreation
  async function processZipFileMinimal(file, dateStr, tzOffsetMinutes, forceNewProject) {
    log(`Memuat ZIP: ${file.name}`);
    
    // Buat ZIP baru dengan copy semua file kecuali project.csv dan landmark.csv
    const newZip = new JSZip();
    const originalZip = await JSZip.loadAsync(file, {
      createFolders: true,
      checkCRC32: true // validasi integritas
    });

    // Copy semua file kecuali CSV yang akan diproses
    for (let filename in originalZip.files) {
      const entry = originalZip.files[filename];
      if (/(^|\/)project\.csv$/i.test(filename) || (forceNewProject && /(^|\/)landmark\.csv$/i.test(filename))) {
        continue; // Skip CSV yang akan diproses
      }
      
      if (entry.dir) {
        newZip.folder(filename);
      } else {
        const content = await entry.async('uint8array');
        newZip.file(filename, content, {
          date: entry.date,
          dosPermissions: entry.dosPermissions,
          unixPermissions: entry.unixPermissions,
          comment: entry.comment
        });
      }
    }

    // Proses project.csv (wajib ada)
    const projectEntry = Object.values(originalZip.files).find(f => /(^|\/)project\.csv$/i.test(f.name));
    if (!projectEntry) {
      log(`  ➜ project.csv tidak ditemukan di ${file.name} (dilewati)`);
      return null;
    }

    const projectCsvText = await projectEntry.async('text');
    const projectResult = await processCsv(projectCsvText, 'project.csv', dateStr, tzOffsetMinutes, forceNewProject);
    
    if (!projectResult) {
      log(`  ➜ Gagal memproses project.csv di ${file.name}`);
      return null;
    }

    // Tambahkan project.csv yang sudah dimodifikasi
    newZip.file(projectEntry.name, projectResult.csvContent, {
      date: projectEntry.date,
      dosPermissions: projectEntry.dosPermissions,
      unixPermissions: projectEntry.unixPermissions,
      comment: projectEntry.comment
    });

    let totalChanged = projectResult.changed;

    // Proses landmark.csv jika ada dan forceNewProject aktif
    if (forceNewProject) {
      const landmarkEntry = Object.values(originalZip.files).find(f => /(^|\/)landmark\.csv$/i.test(f.name));
      if (landmarkEntry) {
        const landmarkCsvText = await landmarkEntry.async('text');
        const landmarkResult = await processCsv(landmarkCsvText, 'landmark.csv', dateStr, tzOffsetMinutes, forceNewProject);
        
        if (landmarkResult) {
          newZip.file(landmarkEntry.name, landmarkResult.csvContent, {
            date: landmarkEntry.date,
            dosPermissions: landmarkEntry.dosPermissions,
            unixPermissions: landmarkEntry.unixPermissions,
            comment: landmarkEntry.comment
          });
          totalChanged += landmarkResult.changed;
          log(`  📍 landmark.csv diproses: ${landmarkResult.changed} perubahan`);
        }
      } else {
        log(`  ➜ landmark.csv tidak ditemukan (dilewati)`);
      }
    }

    // Generate ZIP baru dengan preserve metadata sebanyak mungkin
    const outBlob = await newZip.generateAsync({ 
      type: 'blob',
      compression: "DEFLATE",
      compressionOptions: { level: 1 }, // kompresi ringan
      platform: "DOS" // untuk kompatibilitas Windows
    });

    log(`  ✔️ Selesai: ${file.name} — ${totalChanged} total perubahan.`);
    return { blob: outBlob, filename: file.name, changed: totalChanged };
  }

  btnProcess.addEventListener('click', async () => {
    const dateStr = document.getElementById('dateInput').value;
    const tzOffsetMinutes = parseInt(document.getElementById('tzSelect').value, 10);
    const forceNewProject = document.getElementById('forceNewProject').checked;
    const input = document.getElementById('zipInput');
    const files = Array.from(input.files || []);

    downloadsEl.innerHTML = '';

    if (!dateStr) { log('Masukkan tanggal terlebih dahulu.'); return; }
    if (!files.length) { log('Pilih minimal satu file ZIP.'); return; }

    btnProcess.disabled = true;
    log(`Memulai proses untuk ${files.length} file...`);
    if (forceNewProject) {
      log('🔄 Mode: Paksa Project Baru (reset server_id & is_sent)');
    }
    
    for (const f of files) {
      try {
        // Gunakan processZipFileMinimal untuk preserve metadata maksimal
        const result = await processZipFileMinimal(f, dateStr, tzOffsetMinutes, forceNewProject);
        if (result) {
          // Buat link unduhan dengan timestamp untuk menghindari caching
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
          const a = document.createElement('a');
          a.href = URL.createObjectURL(result.blob);
          a.download = result.filename.replace(/\.zip$/i, '') + `_updated_${timestamp}.zip`;
          a.textContent = `Unduh ${a.download}`;
          a.className = 'inline-block px-3 py-2 rounded-xl bg-emerald-600 text-white text-sm shadow hover:bg-emerald-700';

          const wrap = document.createElement('div');
          wrap.appendChild(a);
          downloadsEl.appendChild(wrap);
        }
      } catch (err) {
        console.error(err);
        log(`  ❌ Error pada ${f.name}: ${err.message || err}`);
      }
    }
    log('Semua proses selesai. Silakan unduh file hasil.');
    btnProcess.disabled = false;
  });

  btnClear.addEventListener('click', () => {
    document.getElementById('zipInput').value = '';
    document.getElementById('dateInput').value = '';
    document.getElementById('forceNewProject').checked = false;
    downloadsEl.innerHTML = '';
    logEl.textContent = '';
  });
</script>
</body>
</html>
